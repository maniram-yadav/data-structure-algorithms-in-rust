https://practice.course.rs/compound-types/array.html


fn main() {
    // We can ignore parts of the array type or even the whole type, let the compiler infer it for us
    let arr0 = [1, 2, 3];
    let arr: [char; 3] = ['a', 'b', 'c'];
    
    assert!(std::mem::size_of_val(&arr) ==12);

    println!("Success!");
}


fn main() {
    // Fill the blank with proper array type
    let arr: [i32;5] = [1, 2, 3, 4, 5];

    // Modify the code below to make it work
    assert!(arr.len() == 5);

    println!("Success!");
}


fn main() {
    // Fill the blank
    let list: [i32; 100] =[1;100];

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!("Success!");
}

// Fix the error
fn main() {
    let names = [String::from("Sunfei"), "Sunface".to_string()];
    
    // `Get` returns an Option<&T>, it's safe to use
    let name0 = names.get(0).unwrap();

    // But indexing is not safe
    let _name1 = &names[1];
    println!("{:?}",names);

    println!("Success!");
}

https://practice.course.rs/compound-types/slice.html


// Fix the errors, DON'T add new lines!
fn main() {
    let arr = [1, 2, 3];
    let s1: &[i32] = &arr[0..2];

    // let s2: str = "hello, world" as str;

    println!("Success!");
}

fn main() {
    let arr: [char; 3] = ['中', '国', '人'];

    let slice = &arr[..2];
    
    // Modify '8' to make it work
    // TIPS: slice( reference ) IS NOT an array, if it is an array, then `assert!` will be passed: Each of the two chars '中' and '国'  occupies 4 bytes, 2 * 4 = 8
    assert!(std::mem::size_of_val(&slice) == 16);

    println!("Success!");
}

fn main() {
    let arr: [i32; 5] = [1, 2, 3, 4, 5];
    // Fill the blanks to make the code work
    let slice:&[i32] = &arr[1..4];
    assert_eq!(slice, &[2, 3, 4]);

    println!("Success!");
}

fn main() {
    let s = String::from("hello");

    let slice1 = &s[0..2];
    // Fill the blank to make the code work, DON'T USE 0..2 again
    let slice2 = &s[0..2];

    assert_eq!(slice1, slice2);

    println!("Success!");
}


// Fix errors
fn main() {
    let mut s = String::from("hello world");

    let letter = first_letter(&s);
    // let letter_cp = String::from(letter);

    // drop(s);

    
    println!("the first letter is: {}", letter);

    s.clear();
}
fn first_letter(s: &str) -> &str {
    &s[..1]
}



https://practice.course.rs/compound-types/tuple.html


fn main() {
    let _t0: (u8,i16) = (0, -1);
    // Tuples can be tuple's members
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    // Fill the blanks to make the code work
    let t: (u8, u16, i64, &str, String) = (1u8, 2u16, 3i64, "hello", String::from(", world"));

    println!("Success!");
}


// Make it work
fn main() {
    let t = ("i", "am", "sunface");
    assert_eq!(t.1, "am");

    println!("Success!");
}



fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12);
    println!("too long tuple: {:?}", too_long_tuple);
}


fn main() {
    let tup = (1, 6.4, "hello");

    let (x,z,y) = tup;

    assert_eq!(x, 1);
    assert_eq!(y, "hello");
    assert_eq!(z, 6.4);

    println!("Success!");
}


fn main() {
    // Fill the blank, need a few computations here.
    let (x, y) = sum_multiply((2,3));

    assert_eq!(x, 5);
    assert_eq!(y, 6);

    println!("Success!");
}

fn sum_multiply(nums: (i32, i32)) -> (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}


